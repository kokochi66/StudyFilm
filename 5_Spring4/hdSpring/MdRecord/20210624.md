<h1> 20210624 스프링 실습 프로젝트 공부내용 </h1>
<h2>16장 : 예외처리 </h2>
<img src="https://user-images.githubusercontent.com/61536109/123201736-3f0c2e80-d4ee-11eb-917b-880e13687ac8.png" height="150px"/>
<p>
	웹 컨테이너는 예외처리를 하여 기본 에러 페이지를 표시해준다. 이런 페이지는 어플리케이션 서버의 내부 정보가 일반 사용자들에게 노출되어 프레임워크 보안 취약점을 노린 공격을 받을 수 있기 때문에, <strong>사용자가 최대한 직접 예외처리를 하여 에러 페이지를 표시</strong>하게 해야한다.
</p> <br><br>
<h3> 상태 코드를 사용한 에러 페이지 설정 </h3>
<p>
	웹 컨테이너 설정 파일(web.xml) 에 <strong>상태 코드</strong>를 설정하고, 이동 대상 페이지를 지정하는 방법을 사용할 수 있다.
</p>
<pre>
&lt;error-page&gt;
	&lt;err-code&gt;400&lt;/err-code&gt;
	&lt;location&gt;/WEB-INF/views/error/errorCommon.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
	&lt;err-code&gt;404&lt;/err-code&gt;
	&lt;location&gt;/WEB-INF/views/error/errorCommon.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
	&lt;err-code&gt;500&lt;/err-code&gt;
	&lt;location&gt;/WEB-INF/views/error/errorCommon.jsp&lt;/location&gt;
&lt;/error-page&gt;
</pre>
<p> web.xml </p> <br><br>
<h3> 예외 타입을 사용한 에러 페이지 설정 </h3>
<p> 웹 컨테이너 설정 파일(web.xml)에 <strong>예외 타입</strong>을 설정하고 이동 대상 페이지를 지정한다.</p>
<pre>
&lt;error-page&gt;
	&lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt;
	&lt;location&gt;/WEB-INF/views/error/errorCommon.jsp&lt;/location&gt;
&lt;/error-page&gt;
</pre>
<p> web.xml </p> <br><br>
<h3> 기본 에러 페이지 설정 </h3>
<p> 웹 컨테이너 설정 파일(web.xml)에 location 요소만 지정하여 기본 에러 페이지를 설정할 수 있다.</p>
<pre>
&lt;error-page&gt;
	&lt;location&gt;/WEB-INF/views/error/errorCommon.jsp&lt;/location&gt;
&lt;/error-page&gt;
</pre>
<p> web.xml </p> <br><br>
<h3> 예외처리 어노테이션 </h3>
<p> @ControllerAdvice와 @ExceptionHandler를 이용해서 예외를 처리한다. 여기서 @ConstrollerAdvice는 스프링 컨트롤러에서 예외 처리하는 핸들러 클래스임을 명시하고, @ExceptionHandler는 괄호안에 설정한 예외 타입을 해당 메서드가 처리하도록 한다. 여기서 클래스를 정의하려면 context에서 읽을 수 있어야하기 때문에 scan설정을 해주어야한다.</p>
<pre>
<strong>@ControllerAdvice</strong>
public class CommonExceptionHandler {
	private static Logger logger = LoggerFactory.getLogger(CommonExceptionHandler.class);
	<strong>@ExceptionHandler(Exception.class)</strong>
	public String handle(Exception e) {
		return "error/errorCommon";
	}
}
</pre>
<p> CommonExceptionHandler.java </p> <br><br>
<h3> 예외정보를 뷰에 출력 </h3>
<p> 예외 내용을 Model 객체를 이용하여 뷰 화면에서 출력할 수 있다.</p>
<pre>
@ExceptionHandler(Exception.class)
public String handle(Exception ex, Model model) {
	<strong>model.addAttribute("exception", ex);</strong>
	return "/error/errorCommon2";
}
</pre>
<p> CommonExceptionHandler.java </p>
<pre>
&lt;h4&gt;${exception.getMessage()}&lt;/h4&gt;
&lt;ul&gt;
	&lt;c:forEach items=&quot;${exception.getStackTrace()}&quot; var=&quot;stack&quot;&gt;
		&lt;li&gt; ${stack.toString()} &lt;/li&gt;
	&lt;/c:forEach&gt;
&lt;/ul&gt;
</pre>
<p> errorCommon2.jsp </p> <br><br>
<h3> 404 에러페이지 처리 </h3>
<p> 404 에러를 처리할 수 있도록 DispatcherServlet에 throwExceptionIfNoHandlerFound 속성을 true로 설정하고, 해당 에러를 처리하도록 코드를 구성한다.</p>
<pre>
&lt;servlet&gt;
	&lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
	&lt;init-param&gt;
		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
		&lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt;
	&lt;/init-param&gt;
	&lt;!-- 404에러를 처리하도록 throwExceptionIfNoHandlerFound를 true로 설정한다. --&gt;
	<strong>&lt;init-param&gt;
		&lt;param-name&gt;throwExceptionIfNoHandlerFound&lt;/param-name&gt;
		&lt;param-value&gt;true&lt;/param-value&gt;
	&lt;/init-param&gt;</strong>
	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</pre>
<p> web.xml (DispatcherServlet 선언부분 내부에 굵기처리 된 코드를 넣는다.) </p>
<pre>
@ExceptionHandler(NoHandlerFoundException.class)
@ResponseStatus(HttpStatus.NOT_FOUND)
public String handle404(Exception e) {
	return "error/error404";
}
</pre>
<p> CommonExceptionHandler.java </p> <br><br>
<h3> 입력값 검증 예외 처리 </h3>
<p> @Valideted 어노테이션을 이용하여, 유효성 검증 메커니즘을 사용할 수 있다. 여기서 BindingResult에 요청 데이터의 바인딩 에러와 검사 에러 정보가 저장되어 에러 확인 시, 조건문을 이용해서 별도의 처리를 메소드 내에 적용할 수 있다. </p>
<pre>
@RequestMapping(value="/register", method=RequestMethod.POST)
public String register(<strong>@Validated Board board, BindingResult result</strong>, Model model) throws Exception {
	if(result.hasErrors()) return"board/register";
	service.register(board);
	model.addAttribute("msg", "등록이 완료되었습니다.");
	return "board/success";
}
</pre>
<p> BoardController.java </p> <br><br><br>
<h2>17장 : 인터셉터 </h2>
<p> 인터셉터는 웹 어플리케이션 내에서 특정한 URI 호출을 가로채는 역할을 한다. 서블릿의 필터와 스프링 MVC의 인터셉터는 특정 URI에 접근할 때 제어하는 용도로 사용되는 공통점이 있지만, 인터셉터는 스프링 내의 모든 객체에 접근이 가능하지만, 필터는 스프링 내의 객체에는 접근이 불가능하다.</p> <br>
<h3> HandleInterceptorAdapter 클래스를 이용한 구현 </h3>

- preHandle : 지정된 컨트롤러의 동작 이전에 가로챈다.
- postHandle : 지정된 컨트롤러의 동작 이후에 화면 처리전에 동작한다.
- afterCompletion : DispatcherServlet의 화면 처리가 완료된 상태에서 처리
<pre>
&lt;beans:bean id=&quot;loginInterceptor&quot; class=&quot;org.hdcd.common.interceptor.LoginInterceptor&quot;&gt;&lt;/beans:bean&gt;
</pre>
<p> servlet-context.xml ( LoginInterceptor 클래스를 빈으로 등록 ) </p>
<pre>
&lt;interceptors&gt;
	&lt;interceptor&gt;
		&lt;mapping path=&quot;/login&quot; /&gt;
		&lt;beans:ref bean=&quot;loginInterceptor&quot; /&gt;
	&lt;/interceptor&gt;
&lt;/interceptors&gt;
</pre>
<p> servlet-context.xml ( 원하는 URL에 적절한 패턴을 적용하여 지정 ) </p>
<pre>
public class LoginInterceptor extends HandlerInterceptorAdapter {
	private static final Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);

	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		logger.info("preHandle");
		return true;
	}
	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
		logger.info("postHandle");
	}
	@Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
		logger.info("afterCompletion");
	}
}
</pre>
<p> LoginInterceptor.java</p><br><br>
<h3> 인터셉터를 활용한 세션 처리하기 </h3>
<p> 세션을 컨트롤러가 아닌, 인터셉터에서 처리게 함으로 써, 세션을 관리하는 로직을 별도로 구축할 수 있다.</p>
<pre>
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
	HttpSession session = request.getSession();	// 세션을 가져온다
	if(session.getAttribute(USER_INFO) != null) {	// 세션에 userinfo가 이미 존재한다면
		session.removeAttribute(USER_INFO);	// userinfo 세션을 삭제해준다.
	}
	return true;
}
</pre>
<p> /login 경로에 인터셉터를 설정해두면, 해당 경로의 컨트롤러를 처리한다. 여기서 세션이 존재하면 해당 세션을 삭제함으로써, 자동 로그아웃 기능을 생성하였다. </p>
<pre>
@Override
public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
	HttpSession session = request.getSession();
	ModelMap modelMap = modelAndView.getModelMap();
	Object member = modelMap.get("user");	// modelMap에서 user에 해당하는 객체를 가져온다.
	if(member != null) {
		session.setAttribute(USER_INFO, member);	// user 객체가 존재한다면, 해당 객체를 USER_INFO 세션으로 등록해준다.
		response.sendRedirect("/");
	}
}
</pre>
<p> postHandle은 로그인 내용을 처리하며, 입력된 값이 존재하면 해당 값으로 로그인 세션을 등록해주는 작업을 구현한다. 이를 통해서 인터셉터에 세션처리가 별도로 지정이 가능하다. </p><br><br><br>
<h2>18장 : 스프링 시큐리티 </h2>
<p> 스프링 시큐리티는 어플리케이션에서 보안 기능을 구현하는데 사용하는 프레임 워크이며, 필터 기반으로 동작하여, MVC와 분리되어 동작한다. 기본 보안 기능으로는 인증(Authentication)과 인가(Authorization)이 존재한다. </p>

<h3> 스프링 시큐리티 제공 기능 </h3>

- 세션관리
- 로그인 처리
- CSRF 토큰 처리(크로스 사이트 요청 위조CSRF)
- 암호화 처리
- 자동 로그인

<h3> 스프링 시큐리티 설정 </h3>
<pre>
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
	&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
	&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;
	&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
	&lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;
	&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</pre>
<p>pom.xml (스프링 시큐리티 라이브러리 의존관계 정의)</p>
<pre>
&lt;context-param&gt;
	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
	&lt;param-value&gt;/WEB-INF/spring/root-context.xml
		<strong>/WEB-INF/spring/security-context.xml</strong>
	&lt;/param-value&gt;
&lt;/context-param&gt;
</pre>
<p>web.xml (contextConfigLocation에 시큐리티 설정 파일 지정) </p>
<pre>
&lt;filter&gt;
	&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
	&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</pre>
<p> web.xml (스프링 필터 클래스를 서블릿 컨테이너에 등록) </p>
<pre>
&lt;security:http&gt;
	&lt;security:form-login /&gt;
&lt;/security:http&gt;
&lt;security:authentication-manager&gt;&lt;/security:authentication-manager&gt;
</pre>
<p>security-context.xml</p><br><br>
<h3>접근 제한 설정</h3>
<p> 시큐리티 설정을 사용하여 URI에 대한 접근 제한을 걸 수 있다.</p>
<pre>
&lt;security:http&gt;
	&lt;security:intercept-url pattern=&quot;/board/list&quot; access=&quot;permitAll&quot;/&gt;
	&lt;security:intercept-url pattern=&quot;/board/register&quot; access=&quot;hasRole(&apos;ROLE_MEMBER&apos;)&quot;/&gt;
	&lt;security:intercept-url pattern=&quot;/notice/list&quot; access=&quot;permitAll&quot;/&gt;
	&lt;security:intercept-url pattern=&quot;/notice/register&quot; access=&quot;hasRole(&apos;ROLE_ADMIN&apos;)&quot;/&gt;
	&lt;security:form-login /&gt;
&lt;/security:http&gt;
</pre>
<p>security:intercept_url 패턴을 이용해서 접근 제한을 설정한다. 위와 같은 설정을 통해서 /list 에 해당하는 url 패턴은 모든 사용자가 접근이 가능하지만 register url에는 각각 ROLE_MEMBER, ROLE_ADMIN 권한의 사용자만 접근이 가능하게 된다.</p><br><br>
<h3>로그인 처리</h3>
<pre>
&lt;security:authentication-manager&gt;
	&lt;security:authentication-provider&gt;
		&lt;security:user-service&gt;
			&lt;security:user name=&quot;member&quot; password=&quot;{noop}1234&quot; authorities=&quot;ROLE_MEMBER&quot;/&gt;
			&lt;security:user name=&quot;admin&quot; password=&quot;{noop}abcd&quot; authorities=&quot;ROLE_MEMBER, ROLE_ADMIN&quot;/&gt;
		&lt;/security:user-service&gt;
	&lt;/security:authentication-provider&gt;
&lt;/security:authentication-manager&gt;
</pre>
<p>위 설정으로 메모리 상에 아이디와 패스워드를 지정하고 로그인을 처리할 수 있다. 스프링 시큐리티 5버전부터는 패스워드 암호화 처리기를 반드시 이용하도록 변경되어있다. 현재 테스트로 암호화 처리기를 사용하지 않도록 {noop}문자열을 비밀번호 앞에 사용하였다.</p>
<p> 이후 사용자 설정에 따른 로그인/로그아웃 방법과 URL 지정하는 방법에 대한 자세한 부분은 코드를 확인하도록 한다. </p> <br><br>
<h3>JDBC를 이용한 인증/인가 처리</h3>
<pre>
&lt;bean id=&quot;customPasswordEncoder&quot; class=&quot;org.hdcd.common.security.CustomNoOpPasswordEncoder&quot;&gt;&lt;/bean&gt;
</pre>
<pre>
&lt;security:authentication-manager&gt;
	&lt;security:authentication-provider&gt;
		&lt;security:jdbc-user-service data-source-ref=&quot;dataSource&quot;/&gt;
		&lt;security:password-encoder ref=&quot;customPasswordEncoder&quot;/&gt;
	&lt;/security:authentication-provider&gt;
&lt;/security:authentication-manager&gt;
</pre>
<p> security-context.xml에 위와같이 사용자가 정의한 비밀번호 암호화 처리기를 빈으로 등록하고, 인증 매니저에 인증 제공자를 등록해준다. 그 후 MySQL, JDBC 설정을 해주면 JDBC 인증처리가 가능하다. </p>
<p> 암호화 처리기 빈에 대한 구현은 프로젝트 파일의 <a href="https://github.com/kokochi66/StudyFilm_BackEnd_kokochi/blob/main/5_Spring4/hdSpring/CH1802/src/main/java/org/hdcd/common/security/CustomNoOpPasswordEncoder.java">CustomNoOpPasswordEncoder.java</a> 파일을 참고하자. </p> <br><br>

<h3> 사용자 테이블을 이용한 인증/인가 처리 </h3>