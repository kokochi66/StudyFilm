<h1> 20210623 스프링 실습 프로젝트 공부내용 </h1>


<h2>14장 : AOP </h2>

AOP는  관점 지향 프로그래밍(Aspect Oriented Programming)을 의미하며, 핵심 기능에만 집중할 수 있도록 공통 기능의 코드를 따로 빼놓는 프로그래밍 방법이다.<br><br>

<h3> AOP의 주요 용어 </h3>

- Aspect : 여러 객체에 공통으로 적용되는 기능
- Advice : Aspect를 언제 핵심 코드에 적용할지를 정의
- Joinpoint : Advice를 적용 가능한 지점을 의미
- Pointcur : Joinpoint의 부분집합, Advice가 적용되는 JoinPoint 
- Weaving : Advice를  핵심 코드에 적용하는 일 <br><br>

<h3> 스프링이 지원하는 Advice의 유형 </h3>

- Before : 대상 메소드 호출 이전
- After Reurning : 대상 메소드가 예외없이 실행된 이후
- After Throwing : 대상  메소드 실행 도중 예외가 발생했을 때
- After advice : 대상 메소드 실행 이후
- Around Advice : 대상 메소드 실행 전/후  <br><br>


<h3> AOP 구현을 위한 설정 </h3>
<pre>
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
        &lt;version&gt;1.5.4&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.5.4&lt;/version&gt;
    &lt;/dependency&gt;
</pre>
<p> pom.xml ( 의존관계 정의 ) </p> <br>
<pre>
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
</pre>
<pre>
    &lt;context:component-scan base-package=&quot;org.hdcd.common.aop&quot;&gt;&lt;/context:component-scan&gt;
</pre>
<p>root-context.xml ( AOP활성화 태그와 컴포넌트 스캔 대상으로 등록하기 ) </p><br><br>


<h3> 포인트 컷 표현식 (execution 지시자) </h3>

<img src="https://user-images.githubusercontent.com/61536109/123069162-7f67a000-d44d-11eb-8fae-a49568d54e9c.png" height="300px" /> <br>
<p>execution 지시자의 기본 표현방식은 위와 같다.</p><br>

<pre>
    @Before(&quot;execution(* org.hdcd.service.BoardService*.*(..))&quot;)
</pre>
<p>예시로 위와같이 사용할 수 있으며, org.hdcd.servcie.BoardService 클래스에 속한 임의의 메소드를 대상으로 한다는 의미가 된다.</p><br><br>

<p>각 Advice 유형 별 구현은 다음 코드와 같다. </p><br>
<pre>
    	@Component
	@Aspect
	public class ServiceLoggerAdvice {

		private static final Logger logger = LoggerFactory.getLogger(ServiceLoggerAdvice.class);

		@Before("execution(* org.hdcd.service.BoardService*.*(..))")
		public void startLog(JoinPoint jp) {
			logger.info("Before Advice -> " + jp.getSignature());
		}

		@AfterReturning("execution(* org.hdcd.service.BoardService*.*(..))")
		public void  logReturning(JoinPoint  jp) {
			logger.info("AfterReturning Advice -> " + jp.getSignature());
		}

		@AfterThrowing(pointcut = "execution(* org.hdcd.service.BoardService*.*(..))", throwing = "e")
		public void  logException(JoinPoint  jp, Exception e) {
			logger.info("AfterThrowing Advice -> " + jp.getSignature());
			logger.info("log Exception -> " + e);
		}

		@After("execution(* org.hdcd.service.BoardService*.*(..))")
		public void  endLog(JoinPoint  jp) {
			logger.info("After Advice -> " + jp.getSignature());
		}

		@Around("execution(* org.hdcd.service.BoardService*.*(..))")
		public Object  timeLog(ProceedingJoinPoint pip) throws Throwable {

			long startTime = System.currentTimeMillis();
			logger.info("Around Advice1 ->  " + Arrays.toString(pip.getArgs()));

			Object result = pip.proceed();
			long endTime = System.currentTimeMillis();
			logger.info("Around Advice2 ->  " + pip.getSignature().getName() + " : " + (endTime  - startTime));
			return result;
		}

	}
</pre> <br><br>

<h3> 메소드 정보 가져오기 </h3>
<p> JoinPoint 객체를 이용해서 객체의 메소드 정보에 대해서 가져올 수 있다. 예제는 다음과 같다. </p>
<pre>  
    @Before("excution(* org.hdcd.service.BoardService*.*(..))")
	public void log(JoinPoint jp) {
		Object targetObject = jp.getTarget();
		logger.info("target Object = " + targetObject);
		
		Object thisObject = jp.getThis();
		logger.info("this Object = " + thisObject);
		
		Object[] args = jp.getArgs();
		logger.info("args.length = " + args.length);
	}
</pre>




























