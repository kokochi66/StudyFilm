<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>line_jss</title>
    <link rel="stylesheet" href="../jss.css">
</head>
<body>

<div id="wrap">
    <div class="sp">
        <div class="sp-box">스프링 프레임워크에 대해서</div>
        <div class="an-box">
            스프링 프레임워크는 자바 플랫폼 상에서, 개발을 편하고 안정적으로 할 수 있도록 만든 툴이다. <br>
            스프링의 대표적인 특징으로는 POJO, IoC 컨테이너, DI와 DL, 그리고 AOP(관점 지향 프로그래밍)등이 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 DI와 DL에 대해서</div>
        <div class="an-box">
            Dependency Injection 즉, 의존성 주입이란 객체간의 의존관계를 외부의 조립기를 통해 조립하듯이 정의하는 IoC 컨테이너의 구체적인 구현 방식이다.<br>
            일반적으로 스프링은 Bean의 설정파일을 통해서 객체간의 의존관계를 정의하고, 실제 사용할 시에 Autowired와 같은 어노테이션을 통해서 의존성을 주입하여, new 연산자와 같은 생성자 없이 객체를 주입받게 한다.<br>
            이렇게 정의한 객체를 Dependency Lookup 즉 검색을 통해, Bean에 접근한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 IoC에 대해서</div>
        <div class="an-box">
            일반적인 자바는 개발자가 직접 new 연산자를 통해서 객체를 생성하며 제어를 해준다.<br>
            Spring에서는 설정을 통해서 스프링 컨테이너에 Bean을 등록하기만 하면 컨테이너에서 스스로 Bean의 생명주기를 관리한다.<br>
            객체에 대한 제어권이 컨테이너로 역전되기 때문에 제어의 역전(Inversion of Control)이라고 부른다.<br>
            결과적으로 객체 관리를 스프링에게 넘김으로써, 코드의 재사용이 쉬워지고, 유지보수가 간단해진다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 POJO에 대해서</div>
        <div class="an-box">
            POJO는 Plain Old Java Object의 약자로, 다른 클래스나 인터페이스를 상속/implement를 받아 추가된 클래스가 아닌, getter, setter와 같은 자바의 기본 기능만 가진 자바 객체이다.<br>
            스프링은 자바의 객체 지향적인 부분에만 집중하며, 특정 클래스나 라이브러리에 종속되지 않는 POJO 구성으로 코드를 짬으로 써, 복잡한 상속구조로부터 벗어난 형식을 띠는 특징이 있다.<br>
            이와 다르게 여러가지 복잡한 상속과 implement관계를 가진 EJB(Enterprise Java Beans)는 간단한 서비스 하나를 가져오기 위해서 복잡한 상속구조를 모두 가져와야하기 때문에 이를 해결하기 위해 모든 상속구조를 고쳐야하는 번거로움이 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 OOP에 대해서</div>
        <div class="an-box">
            Object Oriented Promgramming, 객체 지향 프로그래밍은, 프로그래밍에 필요한 데이터를 갖고 객체를 만들어, 객체간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.<br>
            장점으로는 남이만든 클래스를 쉽게 사용할 수 있고, 상속을 통한 확장이 편해서 코드 재사용에 용이하다.<br>
            그리고 특정 부분에 문제가 생기면 특정 클래스만 수정하면 되므로 유지보수가 쉬우며, 클래스 단위로 모듈화가 가능하므로 대형 프로젝트에 적합하다.<br><br>
            + 클래스 :  문제 해결을 위한 데이터를 속성, 행위, 변수, 메소드로 정의하여 추상화 시킨 것<br>
            ++ 추상화 : 공통적인 속성이나 기능을 묶어서 이름을 붙인 것<br>
            ++ 캡슐화 : 코드를 재수정없이 재활용하는 것, 접근 제어자를 통한 정보은닉(private)<br>
            ++ 상속 : 코드의 일부분을 변경해야 할 경우, 상속받은 자식 클래스에서 해당하는 기능만 다시 재정의 할 수 있게 하는 것<br>
            ++ 다형성 : 하나의 변수명, 함수명, 메소드명이 상황에 따라 다른 의미로 해석되는 것(재정의-오버라이딩)<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 AOP에 대해서</div>
        <div class="an-box">
            객체 지향 프로그래밍을 적용하더라도, 로그, 트랜잭션, 성능테스트 메서드와 같이 공통적으로 반복되는 중복코드가 발생한다.<br>
            이를 해결할 수 있도록, 스프링에서는 실행시에 비즈니스 로직의 앞과 뒤, 혹은 원하는 지점에서 해당하는 공통 관심사를 모듈화하여 실행될 수 있도록 프로그래밍하는 방식이 AOP이다.<br>
            원하는 지점에 중복되는 코드를 하나의 모듈로 줄이기 때문에 유지보수와 재사용에 용이하다는 OOP와 동일한 장점을 갖고 있다.<br><br>
            + Aspect : 여러 곳에서 사용되는 코드를 합쳐서 모듈화 한 것<br>
            + Target : Aspect가 적용되는 위치를 표시<br>
            + Advice : Aspect의 실질적 기능에 대한 구현<br>
            + Joint point : Advice가 Target에 적용되는 시점<br>
            + Pointcut + Joint point의 상세정보를 정의<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">프록시 패턴이란</div>
        <div class="an-box">
            프록시 패턴은 기존 객체를 감싸고있는 객체이며, 기존 객체와 타입이 동일하다. 주로 접근제어나, 부가기능 추가에 사용된다.<br>
            일반적으로 Service 인터페이스가 존재하고, 이를 컨트롤러에서 실행할 때, Service를 implements하는 ServiceImpl 클래스를 만들어서 구현하는 것이 이 패턴에 해당한다.<br>
        </div>
    </div>

    <div class="sp">
        <div class="sp-box">스프링과 부트의 차이점에 대해서</div>
        <div class="an-box">
            스프링 프로젝트를 생성하다보면 만나게 되는 문제점이 있다. 바로 프로젝트를 세팅하는 데에만 시간이 너무 오래걸린다는 것이다.<br>
            빈 등록을 위한 servlet 설정부터, DB연결을 위한 Hibernate Datasource, Entity Manager, Session Factory 등 스프링의 기본 설정을 하는데에는 지나치게 많은 시간이 걸린다.<br>
            스프링 부트 스타터 의존을 활용하면, spring-boot-starter-web 의존 하나에 대부분의 필요한 의존이 자동으로 추가되므로, 개발자는 Dependency 관리와 호환버전에 대해 고민할 필요가 없어지며, 대부분의 필요한 설정을 스프링 부트 스타터와 임베디드 톰캣이 알아서 해준다.<br>
            +내장톰캣 : 별도의 WAS를 이용한다던지, 톰캣에 추가 기능이 필요한 경우에는 외장WAS를 고려해야하나, 실질적으로 내장과 외장의 성능에 큰 차이는 없다고 한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링과 nodeJS의 장점과 단점</div>
        <div class="an-box">
            스프링 MVC<br>
            클라이언트가 요청시마다 쓰레드가 생성되며, 다중 쓰레드로 많은 요청을 동시에 처리할 수 있다.<br>
            너무 많은 요청을 동시에 처리하게 될 경우, 클라이언트가 요청을 계속 기다려야 하기 때문에 블로킹되는 쓰레드가 생겨난다.<br><br>

            nodeJS<br>
            한개의 쓰레드로 요청을 수행하여, 비동기적으로 블로킹 없이 I/O 작업을 수행한다.<br>
            I/O작업보다 단순 CPU 사용이 많은 작업이라면 단일스레드로 동작하는 nodeJS에 적합하지 않다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">MVC1과 MVC2에 대해</div>
        <div class="an-box">
            모델-뷰-컨트롤러 패턴으로, 데이터, DB등이 담겨져있는 모델, 사용자에게 보여지는 화면인 View, 데이터와 로직 사이에 상호동작을 돕는 Controller로 이루어진 패턴을 말한다.<br>
            MVC1패턴 : view와 controller를 모두 JSP에서 담당한다. 재사용성이 매우 떨어지고, 가독성이 떨어져 유지보수가 어려워진다.<br>
            MVC2패턴 : 스프링 프레임워크에서 사용되는 패턴이며, View와 Controller가 완전히 분리되어 유지보수가 쉬워진다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 MVC의 구조와 흐름에 대해서</div>
        <div class="an-box">
            1. dispacter-servlet이 클라이언트로부터 요청을 받는다.<br>
            2. 요청을 넘길 handler 이름을 handler-mapping을 통해 받아온다.<br>
            3. 핸들러매핑이 url을 통해서 서블릿에게 핸들러 이름을 알려준다.<br>
            4. 핸들러 전/후 처리 인터셉터를 확인한다.<br>
            5. 디스패처 서블릿이 핸들러에게 제어권을 넘겨주고, 핸들러는 서비스를 호출, 렌더링하는 뷰 이름을 받아와 디스패처 서블릿에게 전송한다.<br>
            6. 뷰 이름을 뷰 리졸버에게 전달해 필요한 뷰를 생성한다.<br>
            7. 뷰는 모델과 컨트롤러를 활용해 원하는 응답을 생성하여 클라이언트로 뷰를 응답한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">ORM 정의와 종류에 대해</div>
        <div class="an-box">
            Object-relation mapping, 객체 관계 매핑이란 객체 지향 프로그래밍에서 객체와 관계형 DB의 테이블 데이터를 서로 매핑시켜주는 프레임워크다.<br>
            자바에서는 대표적으로 JPA, Mybatis가 존재한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">Mybatis 기술에 대해</div>
        <div class="an-box">
            Mybatis는 ORM기술이 아닌 SQL Builder, SQL Mapper 기술로 분류된다.<br>
            xml 파일에 별도로 동적 쿼리문을 작성하여 DB데이터와 자바 객체를 직접적으로 매핑시켜주는 방법이다.<br>
            SQL 쿼리를 직접 작성하므로 최적화된 쿼리를 구현하며, 다양한 테이블 조인을 자유롭게 조인이 가능하고, 복잡한 쿼리도 작성할 수 있다.<br>
            반복된 쿼리가 발생하고, 데이터베이스 변경에 따라 로직도 함께 변경해주어야하는 번거로움이 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JPA 기술에 대해</div>
        <div class="an-box">
            JPA는 Java Persistence API의 약자로, ORM 기술에 대한 표준 명세이다.<br>
            일반적으로 사용하는 JPA의 구현체는 Hinernate이다.<br>
            JPA에서 제공하는 1차캐시, 쓰기지연, 변경감지, 지연로딩으로 성능상 이점을 얻을 수 있다.<br>
            직접적인 쿼리문 생성 없이, 코드레벨에서 관리되므로 사용이 용이하고 생산성이 높다.<br>
            다만 JPA만을 사용해 복잡한 쿼리문을 만들기에는 다소 무리가 있고, n+1 문제 등의 성능상 이슈가 발생할 수 있다.<br><br>
            + 1차캐시(동일성보장) : JPA를 통해서 DB에서 꺼내온 객체는 JPA의 1차캐시 안에 저장된다. 이후에 테이블에서 이 값을 다시 꺼내더라도 1차캐시 상에서 동일한 값을 꺼내기 때문에 객체 역시 동일한 객체임을 보장한다.<br>
            + 쓰기지연 : JPA는 Entity를 단순 저장한다고 바로 DB에 반영되는 것이 아닌, commit() 메소드가 실행되었을 때 쓰기지연 저장소에 저장되어있던 쿼리를 데이터베이스로 보내는 구조이다.<br>
            + 지연로딩 : 특정 객체가 OneToMany 객체인 경우, 특정 객체를 가져올때 연관된 다른 테이블의 필요한 값은 사용할 때 필요한 값만 나중에 가져오는것이 지연 로딩이다. 이를 즉시 가져올 경우, 특정한 객체 하나만 가져왔는데, 이와 연관된 다른 테이블의 모든 객체를 각각 Select로 가져오는 문제가 발생할 수 있다.<br>
            + 변경감지 : persist가 없더라도, Entity의 변경사항은 JPA에서 자체적으로 감지하고, 실제 DB로 업데이트해준다. 이는 1차캐시에 스냅샷이라는 공간에 값을 저장하고, Entity와 스냅샷 값의 차이가 있다면, update 쿼리로 DB에 반영하는 구조이기 때문이다.<br>
            + n+1문제 : 지연로딩을 하더라도, 결과적으로 데이터를 가져오는 순서를 늦출 뿐, 나중에 해당 데이터를 가져온다면 다시 n개만큼의 데이터를 가져오는 n+1문제에 다다른다.<br>
            이를 해결하기 위해서는 join 셀렉트문 하나만 실행되는 모습을 만들어야한다. 이는 Fetch join을 통해 해결할 수 있는데, jpaRepository에서 지원해주지 않으며, JPQL로 별도로 작성해야한다. <br>
            다만 이럴경우, FetchType이 무의미해지며, 페이징 단위로 데이터를 가져오는것이 불가능하며, 중복된 데이터가 컬렉션에 존재하지 않도록 주의해야한다.<br>
            (중복된 데이터 -> Set을 사용하거나, distinct 사용)<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">DAO와 DTO란?</div>
        <div class="an-box">
            DAO는 Data Access Object로 실제 DB에 접근하는 객체를 말한다.<br>
            DTO는 Data Transfer Object는 계층간 데이터 교환을 위한 객체이다.<br>
            VO는 Value Object로 readonly의 특성을 가진다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JSP와 Servlet에 대해</div>
        <div class="an-box">
            Servlet은 자바를 웹 어플리케이션에서 사용하기 쉽도록 만든 API이다.<br>
            HttpServletRequest/HttpServletResponse를 통해서<br>
            사용자가 보낸 요청을 받고, 처리를 한 후 HttpServlertResponse에 응답 데이터를 담아 사용자에게 보여준다.<br>
            여기서 기본 Servlet을 사용하면 자바 코드 안에 HTML코드를 일일이 기입을 해줘야 하므로, 유지보수에 어려움을 겪는다.<br>
            이를 보완하는 JSP는 HTML안에 자바 코드를 껴넣는 방식으로 동적 웹페이지를 생성할 수 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JDBC란?</div>
        <div class="an-box">
            자바에서 DB와 연결하기 위해 사용되는 API이다.<br>
            JDBC의 흐름은 JDBC 드라이버 로드 > DB 연결 > SQL문 실행 > DB 연결 종료 순이다.<br>
            +JDBC 드라이버 : DB와 통신을 담당하는 자바 클래스로, DB마다 별도의 드라이버가 필요하다.<br>
            +JDBC URL : DB와의 연결을 위한 식별값, 드라이버에 따라 형식이 다름<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 필터와 인터셉터의 차이</div>
        <div class="an-box">
            필터는 스프링 컨테이너가 아닌, 톰캣과 같은 웹 컨테이너에 의해 관리가 되며 ,스프링 디스패처 서블릿으로 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리한다.<br>
            메소드로는 init, doFilter, destroy메소드가 존재한다.<br>
            init : 필터 객체를 초기화하고, 서비스에 추가한다. 1회 메소드 호출한다.<br>
            doFilter : url-pattern에 맞는 모든 HTTP 요청이 전달되기 전/후에 실행되는 메소드이다.<br>
            destroy : 필터 객체를 서비스에서 제거하고, 사용하는 자원을 반환하기 위한 메소드이다.<br>
            보안 관련 공통작업, 문자열 인코딩/압축 등의 작업에 적합하다<br><br>


            인터셉터는 Spring이 제공하는 기술로써, 디스패처 서블릿에서 컨트롤러를 호출하기 전/후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다.<br>
            preHandle : 컨트롤러가 호출되기 전에 실행된다.<br>
            postHandle : 컨트롤러가 호출된 후에 실행된다.<br>
            afterCompletion : 모든 뷰에서 모든 작업이 완료된 후에 실행되며, 리소스를 반환할 때 사용하기에 적합하다.<br>
            인증/인가 등의 공통작업, API 호출에 대한 로깅 등의 작업에 적합하다.<br><br>

            AOP기능을 사용해서 인터셉터를 대신하는 방안을 생가갛ㄹ 수 있지만, Spring의 컨트롤러는 타입과 실행 메소드, 파라미터, 리턴값이 일정하지 않기 때문에 AOP를 적용하기 위해서는 번거로운 부가작업이 생기게 된다.<br>
            그러므로 컨트롤러의 호출과정에 적용되는 부가기능들은 인터셉터를 사용하는 편이 더 낫다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">트랜잭션 처리에 대하여</div>
        <div class="an-box">
            트랜잭션이란, 데이터베이스의 데이터를 추가/삭제할 때 한번에 수행되어야 하는 연산들을 의미합니다. <br>
            이러한 연산들은 원자성, 일관성, 격리성, 영속성 4가지 속성이 항상 유지되어야합니다.<br>
            스프링은 이러한 트랜잭션을 @Transactional이라는 어노테이션을 통해 적용하거나, 트랜잭션 매니저를 등록하여, AOP 설정으로 원하는 위치에 트랜잭션을 적용할 수 있습니다.<br>
            이렇게 적용하는 트랜잭션에는 속성설정이 가능하며, isolation, propagation, readOnly, rollbackFor, norollbackFor, timeout 이 있습니다.<br>
            + isolation : 트랜잭션 격리수준을 말하며, 트랜잭션끼리 얼마나 격리 되어있는지에 대한 정도를 의미합니다.<br><br>
            Read UnCommited : 트랜잭션의 commit, rollback여부와 상관없이 다른 트랜잭션에서 읽는것을 허용 -> 데이터베이스의 일관성 유지가 불가능,<br>
            Dirty Read : 여러 트랜잭션에서 동일한 값을 참조할때, 다른 트랜잭션에서 해당값이 변경되었음에도, 이것이 적용되지 않은채로 다른 트랜잭션이 적용되어, 데이터 정합성에 문제가 생기는 경우<br>
            Read Commited : 변경된 내용은 Commit 되어야만 다른 트랜잭션에서 조회하며, Commit 되지 않았다면 Undo 영역에 백업된 데이터를 가져오는 수준입니다. <br>
            이러면 두 트랜잭션이 동시에 실행되는 경우, 한쪽 트랜잭션에서 변경된 내용이 나중에 Commit된 후에 적용된다면 다른쪽 트랜잭션에서 나중에 Select했을 때, 다른 결과가 나올 수 있습니다. <br>
            이는 한 트랜잭션 내에서 Select 시 항상 같은 결과가 나와야한다는 데이터 정합성에 어긋나는 문제입니다. <br><br>
            Repetable Read : 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회가능<br>
            Phantom Read : 한 트랜잭션 내에서 Select문을 두번 실행시켰을 때, 첫번째 쿼리문에서는 없었던 데이터가, 두번쨰 쿼리문에서는 나타나는 현상 (다른 트랜잭션에서 INSERT하고, 이를 UPDATE했을 때 발생함)<br>
            Serializable : 트랜잭션을 처리하는 모든 자원에 대해서 공유 잠금, 즉 락을 걸어서 다른 트랜잭션이 해당 레코드에 접근하지 못하게함. 가장 단순하면서, 확실하게 트랜잭션을 처리할 수 있음 처리능력이 떨어지며, 성능저하가 발생함<br><br>
            + propagation : 한 트랜잭션 동작 내에서, 다른 트랜잭션을 호출하는 경우, 트랜잭션을 적용하는 범위 지정<br>
            Required : 부모 트랜잭션이 있으면, 부모 트랜잭션을 따름, 없으면 새로 생성<br>
            Required_new : 항상 새로운 트랜잭션을 만듦 (분리)<br>
            Mandatory : 부모 트랜잭션을 따름, 없으면 예외발생<br>
            Supports : 부모 트랜잭션을 따름, 없으면 트랜잭션 없이 동작<br>
            Not_Supports : 트랜잭션 없이 동작, 부모 트랜잭션이 있으면 보류<br>
            Never : 트랜잭션이 사용되지 않도록 강제<br>
            Nested : 트랜잭션이 사용된다면 중첩 트랜잭션을 생성 (트랜잭션 안에 트랜잭션을 생성 => 자신의 커밋과 부모의 트랜잭션과는 영향이 없음)<br><br>
            + readOnly : 트랜잭션을 읽기전용으로 설정, 쓰기동작이 일어나지 않음, INSERT, UPDATE, DELETE 기능이 사용되면 예외처리<br>
            + rollbackFor : 특정한 예외에 대해서 롤백, 혹은 롤백하지 않음<br>
            + timeout : 지정한 시간 내에 메소드, 수행이 완료되지 않으면 rollback<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 AOP의 실무 적용에 대하여</div>
        <div class="an-box">
            인턴에서 스프링 프로젝트의 구성을 확인하여, 스프링 AOP가 어떻게 활용되는지 확인해보았습니다. <br>
            어노테이션을 사용하여 트랜잭션을 적용하는 @Transactional 어노테이션과 달리, 트랜잭션 매니저를 스프링 빈으로 등록하여, AOP로 advice 기능을 사용하여, 원하는 위치에 있는 클래스 파일의 원하는 메소드를 트랜잭션을 적용할 수 있습니다. <br>
            또한 웹 사이트에서 로그인 기록이나, 관리자 페이지 설정 기록등을 저장하기 위해서, 관리자 페이지, 로그인에 별도로 AOP를 설정하여 기록을 남기는 기능을 사용하였습니다. <br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">선언형 트랜잭션과 AOP를 사용한 것과 각각 장단점은 무엇이 있을지</div>
        <div class="an-box">
            어노테이션을 사용해서 트랜잭션을 적용하면, 트랜잭션 설정이 간편하고, 자바단에서 트랜잭션을 설정하기 때문에, 특정한 메소드가 트랜잭션이 설정되어있는지, 아닌지를 구분하기가 쉬운 장점이 있습니다.<br>
            하지만 많은 메소드나, 클래스에 트랜잭션 어노테이션을 모두 적어줘야하기 때문에 메소드 생산성에 어려움이 있을 수 있습니다.<br>
            이런 경우에, 빈 등록을 통해 AOP advice기능을 사용하여 트랜잭션 매니저로 특정한 규칙에 따라 모두 트랜잭션을 설정하는 경우에는 이렇게 일일이 지정하지 않아도 일괄적으로 트랜잭션 적용이 가능하다는 장점이 있습니다.<br>

        </div>
    </div>

    <div class="np">
        <div class="back-box" onclick="lc('./spr_list.html')">돌아가기</div>
    </div>
</div>
<script src="../jss.js"></script>
</body>
</html>