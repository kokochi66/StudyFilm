<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>line_jss</title>
    <link rel="stylesheet" href="../jss.css">
</head>
<body>

<div id="wrap">
    <div class="sp">
        <div class="sp-box">자바의 메모리영역과 상수풀에 대해</div>
        <div class="an-box">
            정적 영역(Static Area)<br>
            클래스 파일의 기본적인 정보가 저장되는 영역이다.<br>
            필드와 메소드정보, 그리고 final이 붙은 상수를 저장하는 상수풀과 static변수가 있다. 이 변수들은 프로그램 종료시까지 메모리에 상주하기 때문에 어디서든지 사용이 가능하다, 무분별하게 사용하면 메모리 부족이 생길 수 있다.<br><br>

            스택 영역 : 자바는 한 쓰레드마다 자신의 스택을 지닌다. 메소드를 호출하면 프레임을 추가하고, 메소드 종료시, 프레임을 제거하는 형태로 되어있다.<br><br>

            힙 영역 : 주로 긴 생명주기를 가진 데이터들이 저장되며, 어플의 모든 메모리 중 스택에 있는 데이터를 제외한 부분이 힙에 들어간다.<br>
            또한 스레드가 몇개든 상관없이 힙은 딱 하나의 영역만 존재한다. 프로그램 실행중 생성되는 모든 객체는 힙 영역에 동적으로 할당되며, Garbage Collector를 통해서 메모리를 반환한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 implements와 extends의 차이</div>
        <div class="an-box">
            자바 implements와 extends의 차이<br>
            extends는 일반 클래스와 abstract 클래스, implement는 interface 상속에 사용된다.<br>
            class-class와 interface-interface는 모두 extends를 사용한다.<br>
            extends는 한 개의 클래스만 상속받을 수 있다.<br>
            implements는 한번에 여러개 상속이 가능하다.<br>
            implements한 클래스는 해당 interface의 모든 메소드를 재정의하여 사용해야한다.<br>
            extends는 부모의 클래스를 상속없이 사용이 가능하다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 객체의 직렬화(serialVersionUID)</div>
        <div class="an-box">
            자바 객체의 직렬화<br>
            자바의 입출력에는 스티림이라는 데이터 통로가 사용된다. 하지만 객체는 바이트형이 아니기 때문에 스트림을 통해서 파일저장하거나 네트워크로 전송이 불가능하다.<br>
            따라서 스트림을 통해 입출력하기 위해서 바이트 배열로 변환하여야하며, 이를 직렬화라고 한다.<br>
            이 과정에서 serialVersionUID를 사용하는데, JVM는 직렬화/역직렬화 시에 클래스에 대한 번호를 부여하며, 버전이 변경되어있다면 새로운 번호를 할당한다. 이 때 클래스 버전이 맞는지 확인하기 위해서 serailVersionUID를 사용하고, 이 값이 다르다면, InvalidClassException 에러를 반환한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 리플렉션이란?</div>
        <div class="an-box">
            자바의 리플렉션은 특정 객체의 구체적인 클래스 타입을 알지 못하더라도 그 클래스의 메소드, 타입, 변수를 접근할 수 있도록 해주는 자바 API이다.<br>
            일반적으로 구체적인 클래스 타입이 정의되어 있지 않다면 메소드를 실행할 수 없다.<br>
            스프링 프레임워크가 대표적이며, 사용되는 클래스가 어떤 타입인지는 정의되어있지 않지만, 실행시점에 의존주입을 통해서 확인하여 사용할 수 있도록 하는 매커니즘으로 되어있다.<br>
            이것이 가능한 이유는 자바 클래스 파일은 바이트 코드로 컴파일되어 static 영역에 위치하게 되며, 클래스 이름만 알고 있다면 언제든지 static 영역에서 클래스 정보를 가져올 수 있기 때문에 가능하다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 클래스 변수 초기화 순서에 대해</div>
        <div class="an-box">
            static 변수 선언부 > 필드 변수 선언부 > 생성자 block(thread-safe한 영역)<br>
        </div>
    </div>

    <div class="sp">
        <div class="sp-box">자바의 제너릭이란?</div>
        <div class="an-box">
            자바 제네릭은 데이터 형식에 의존하지 않고, 하나의 값이 여러가지 데이터 타입을 가질 수 있도록 하는 객체이다.<br>
            제네릭 타입을 사용하는데에 장점은, 특정 부분에서 타입검사를 통해 잘못된 타입이 들어올 수 있는 것을 방지하며, 타입을 지정해주기 때문에 체크하고 변환해줄 필요가 없어 관리가 편하고 재사용성이 높다.<br>
            제네릭 타입은 T(Type), E(Element), K(Key), V(Value), N(Number)가 있다.<br>
            제네릭 타입을 특정한 범위 내로 제한해서 사용하고 싶다면, extends, super, ?를 사용할 수 있다.<br>
            extends는 자손타입만, super는 부모타입만 사용이 가능하며, ?는 와일드카드를 의미한다. 즉, 타입이 지정되지 않는다는 것이다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">박싱과 언박싱이란</div>
        <div class="an-box">
            자바의 컬렉션에 들어가는 타입에는 참조형 값만 넣을 수 있다. String, Integer 와같은 것이 참조형이다.<br>
            여기서 기본형 객체를 참조형인 Wrapper 클래스로 바꿔주는것을 박싱, 반대로 Wrapper 클래스를 기본형 으로 변경하는것을 언박싱이라고 한다.<br>
            추가로 묵시적인 박싱이란,  임의로 박싱을 해주는 것이 아닌, 자동으로 박싱이 되는 것이며, 묵시적인 언박싱은 자동으로 언박싱이 되는 현상이다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 상속과 컴포지션의 차이</div>
        <div class="an-box">
            상속은 IS-A 관계, 컴포지션은 각 객체들간의 HAS-A 관계로 생성하는 것입니다.<br>
            상속은 클래스를 확장해서 부모 클래스에서 데이터를 그대로 물려받는 기능이며, 컴포지션은 클래스 내부의 데이터로 다른 클래스의 객체를 포함할 수 있게 하는 것입니다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">객체지향 개발 5대 원리(SOLID)</div>
        <div class="an-box">
            SRP(단일책임의 원칙) ; 작성되는 클래스는 하나의 기능만 가지며, 제공하는 모든 서비스가 그 하나의 책임을 수행하는데에 집중된다<br>
            ( 책임의 영역이 확실해지기 때문에 한 책임의 변경으로 인한 연쇄작용으로부터 자유로울 수 있어야 한다.)<br><br>

            OCP(개방폐쇄의 원칙) : 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소의 수정은 일어나지 않아야 하며, 기존 구성요소를 쉽게 확장하여 재사용이 가능하도록 만들어야 한다.<br><br>

            LSP(리스코브 치환의 원칙) : 서브타입은 언제나 기반 타입으로 교체할 수 있어야한다( 하위 객체는 항상 상위 객체로 교체가 가능해야한다. )<br>
            ( 상속을 사용하기 위해서는 하위클래스와 상위 클래스간의 IS-A 관계가 있을때만 사용해야하며, 이외의 HAS-A 관계인 경우에는 합성(composition)을 사용해야한다.<br><br>

            ISP(인터페이스 분리의 원칙) : 어떤 클래스가 다른 클래스에 종속되느 경우, 최소한의 인터페이스만을 사용해야한다. 하나의 클래스가 여러 인터페이스를 사용하는 경우, 상속을 하거나, 위임을 통해서 인터페이스를 분리해야한다.<br>
            ( 두 개 이상의 인터페이스가 공유하는 부분의 재사용을 극대화하며, 서로 다른 성격의 인터페이스를 명백히 분리해야한다)<br><br>

            DIP(의존성역전의 원칙) : 상위 계층이 하위 계층에 의존적인 전통의 방식과 달리, 자바는 하위 계층이 상위 계층에게 의존적이게 되며, 상위 계층은 하위 계층의 구현으로부터 독립되어 사용될 수 있게 된다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JVM의 역할은?</div>
        <div class="an-box">
            JVM은 자바를 실행하기위한 가상 기계로, 자바의 바이트 코드를 운영체제에 맞게 해석해주고 실행시켜주는 역할을 한다.<br>
            바이트 코드는 기계어가 아니기 때문에 운영체제에서 바로 실행될수 없다. 이를 운영체제가 이해할 수 있도록 변환해주는것이 JVM의 역할이다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">인터페이스와 추상객체(abstract)를 비교</div>
        <div class="an-box">
            추상클래스는 추상 메서드를 선언하여, 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스이다.<br>
            상속을 위한 클래스이므로, 객체를 별도로 생성할 수 없다.<br><br>

            인터페이스를 사용해서 기본 틀을 구성한다면, 인터페이스의 특징상 모든 기능들을 하위 클래스에서 오버라이딩해야한다.<br>
            그렇다고 extends 상속만을 사용하기엔 extends는 하나의 클래스만 상속받을 수 있다. 그렇기에 상황에 맞게 상속을 사용해야한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 4가지 특징에 대해서(추상화, 캡슐화, 상속, 다형성)</div>
        <div class="an-box">
            추상화 : 객체와 관련된 속성의 이름만을 표시하며, 해당 부분의 세부 정보는 별도의 구현 파일로 숨긴다. (interface에 메소드만을 선언하고, 실제 구현은 상속받은 java 파일에서 작성하는 것)<br>
            캡슐화 : 변경가능성이 높은 부분은 내부로 숨기고, 외부에는 상대적으로 안정적인 부분만 공개한다. (변경가능성이 높은 부분을 모듈화하여 메소드로 만드는 것)<br>
            상속 : 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게 하고, 기능의 일부분을 변경해야할 경우 상속받은 자식 클래스에서 해당 기능만을 재정의하여 사용할 수 있게 한다.<br>
            다형성 : 하나의 변수명,함수명 등이 상황에 따라 다른 의미로 해석될 수 있다. <br>
            (오버라이딩 - 부모클래스와 같은 메소드이름을 재엉의, 오버로딩 - 같은 이름의 함수를 여러개 정의하고, 파라미터를 다르게하여, 파라미터에 따라 다른 메소드가 호출되도록 함)<br>

        </div>
    </div>
    <div class="np">
        <div class="back-box" onclick="lc('./java_list.html')">돌아가기</div>
    </div>
</div>
<script src="../jss.js"></script>
</body>
</html>