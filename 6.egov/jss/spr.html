<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>line_jss</title>
    <link rel="stylesheet" href="jss.css">
</head>
<body>

<div id="wrap">
    <div class="sp">
        <div class="sp-box">스프링 프레임워크에 대해서</div>
        <div class="an-box">
            스프링 프레임워크는 자바 플랫폼 상에서, 개발을 편하고 안정적으로 할 수 있도록 만든 툴이다. <br>
            스프링의 대표적인 특징으로는 POJO, IoC 컨테이너, DI와 DL, 그리고 AOP(관점 지향 프로그래밍)등이 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 DI와 DL에 대해서</div>
        <div class="an-box">
            Dependency Injection 즉, 의존성 주입이란 객체간의 의존관계를 외부의 조립기를 통해 조립하듯이 정의하는 IoC 컨테이너의 구체적인 구현 방식이다.<br>
            일반적으로 스프링은 Bean의 설정파일을 통해서 객체간의 의존관계를 정의하고, 실제 사용할 시에 Autowired와 같은 어노테이션을 통해서 의존성을 주입하여, new 연산자와 같은 생성자 없이 객체를 주입받게 한다.<br>
            이렇게 정의한 객체를 Dependency Lookup 즉 검색을 통해, Bean에 접근한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 IoC에 대해서</div>
        <div class="an-box">
            일반적인 자바는 개발자가 직접 new 연산자를 통해서 객체를 생성하며 제어를 해준다.<br>
            Spring에서는 설정을 통해서 스프링 컨테이너에 Bean을 등록하기만 하면 컨테이너에서 스스로 Bean의 생명주기를 관리한다.<br>
            객체에 대한 제어권이 컨테이너로 역전되기 때문에 제어의 역전(Inversion of Control)이라고 부른다.<br>
            결과적으로 객체 관리를 스프링에게 넘김으로써, 코드의 재사용이 쉬워지고, 유지보수가 간단해진다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 POJO에 대해서</div>
        <div class="an-box">
            POJO는 Plain Old Java Object의 약자로, 다른 클래스나 인터페이스를 상속/implement를 받아 추가된 클래스가 아닌, getter, setter와 같은 자바의 기본 기능만 가진 자바 객체이다.<br>
            스프링은 자바의 객체 지향적인 부분에만 집중하며, 특정 클래스나 라이브러리에 종속되지 않는 POJO 구성으로 코드를 짬으로 써, 복잡한 상속구조로부터 벗어난 형식을 띠는 특징이 있다.<br>
            이와 다르게 여러가지 복잡한 상속과 implement관계를 가진 EJB(Enterprise Java Beans)는 간단한 서비스 하나를 가져오기 위해서 복잡한 상속구조를 모두 가져와야하기 때문에 이를 해결하기 위해 모든 상속구조를 고쳐야하는 번거로움이 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 OOP에 대해서</div>
        <div class="an-box">
            Object Oriented Promgramming, 객체 지향 프로그래밍은, 프로그래밍에 필요한 데이터를 갖고 객체를 만들어, 객체간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.<br>
            장점으로는 남이만든 클래스를 쉽게 사용할 수 있고, 상속을 통한 확장이 편해서 코드 재사용에 용이하다.<br>
            그리고 특정 부분에 문제가 생기면 특정 클래스만 수정하면 되므로 유지보수가 쉬우며, 클래스 단위로 모듈화가 가능하므로 대형 프로젝트에 적합하다.<br><br>
            + 클래스 :  문제 해결을 위한 데이터를 속성, 행위, 변수, 메소드로 정의하여 추상화 시킨 것<br>
            ++ 추상화 : 공통적인 속성이나 기능을 묶어서 이름을 붙인 것<br>
            ++ 캡슐화 : 코드를 재수정없이 재활용하는 것, 접근 제어자를 통한 정보은닉(private)<br>
            ++ 상속 : 코드의 일부분을 변경해야 할 경우, 상속받은 자식 클래스에서 해당하는 기능만 다시 재정의 할 수 있게 하는 것<br>
            ++ 다형성 : 하나의 변수명, 함수명, 메소드명이 상황에 따라 다른 의미로 해석되는 것(재정의-오버라이딩)<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 AOP에 대해서</div>
        <div class="an-box">
            객체 지향 프로그래밍을 적용하더라도, 로그, 트랜잭션, 성능테스트 메서드와 같이 공통적으로 반복되는 중복코드가 발생한다.<br>
            이를 해결할 수 있도록, 스프링에서는 실행시에 비즈니스 로직의 앞과 뒤, 혹은 원하는 지점에서 해당하는 공통 관심사를 모듈화하여 실행될 수 있도록 프로그래밍하는 방식이 AOP이다.<br>
            원하는 지점에 중복되는 코드를 하나의 모듈로 줄이기 때문에 유지보수와 재사용에 용이하다는 OOP와 동일한 장점을 갖고 있다.<br><br>
            + Aspect : 여러 곳에서 사용되는 코드를 합쳐서 모듈화 한 것<br>
            + Target : Aspect가 적용되는 위치를 표시<br>
            + Advice : Aspect의 실질적 기능에 대한 구현<br>
            + Joint point : Advice가 Target에 적용되는 시점<br>
            + Pointcut + Joint point의 상세정보를 정의<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">프록시 패턴이란</div>
        <div class="an-box">
            프록시 패턴은 기존 객체를 감싸고있는 객체이며, 기존 객체와 타입이 동일하다. 주로 접근제어나, 부가기능 추가에 사용된다.<br>
            일반적으로 Service 인터페이스가 존재하고, 이를 컨트롤러에서 실행할 때, Service를 implements하는 ServiceImpl 클래스를 만들어서 구현하는 것이 이 패턴에 해당한다.<br>
        </div>
    </div>

    <div class="sp">
        <div class="sp-box">스프링과 부트의 차이점에 대해서</div>
        <div class="an-box">
            스프링 프로젝트를 생성하다보면 만나게 되는 문제점이 있다. 바로 프로젝트를 세팅하는 데에만 시간이 너무 오래걸린다는 것이다.
            빈 등록을 위한 servlet 설정부터, DB연결을 위한 Hibernate Datasource, Entity Manager, Session Factory 등 스프링의 기본 설정을 하는데에는 지나치게 많은 시간이 걸린다.
            스프링 부트 스타터 의존을 활용하면, spring-boot-starter-web 의존 하나에 대부분의 필요한 의존이 자동으로 추가되므로, 개발자는 Dependency 관리와 호환버전에 대해 고민할 필요가 없어지며, 대부분의 필요한 설정을 스프링 부트 스타터와 임베디드 톰캣이 알아서 해준다.
            +내장톰캣 : 별도의 WAS를 이용한다던지, 톰캣에 추가 기능이 필요한 경우에는 외장WAS를 고려해야하나, 실질적으로 내장과 외장의 성능에 큰 차이는 없다고 한다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링과 nodeJS의 장점과 단점</div>
        <div class="an-box">
            스프링 MVC
            클라이언트가 요청시마다 쓰레드가 생성되며, 다중 쓰레드로 많은 요청을 동시에 처리할 수 있다.
            너무 많은 요청을 동시에 처리하게 될 경우, 클라이언트가 요청을 계속 기다려야 하기 때문에 블로킹되는 쓰레드가 생겨난다.

            nodeJS
            한개의 쓰레드로 요청을 수행하여, 비동기적으로 블로킹 없이 I/O 작업을 수행한다.
            I/O작업보다 단순 CPU 사용이 많은 작업이라면 단일스레드로 동작하는 nodeJS에 적합하지 않다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">MVC1과 MVC2에 대해</div>
        <div class="an-box">
            모델-뷰-컨트롤러 패턴으로, 데이터, DB등이 담겨져있는 모델, 사용자에게 보여지는 화면인 View, 데이터와 로직 사이에 상호동작을 돕는 Controller로 이루어진 패턴을 말한다.
            MVC1패턴 : view와 controller를 모두 JSP에서 담당한다. 재사용성이 매우 떨어지고, 가독성이 떨어져 유지보수가 어려워진다.
            MVC2패턴 : 스프링 프레임워크에서 사용되는 패턴이며, View와 Controller가 완전히 분리되어 유지보수가 쉬워진다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 MVC의 구조와 흐름에 대해서</div>
        <div class="an-box">
            1. dispacter-servlet이 클라이언트로부터 요청을 받는다.
            2. 요청을 넘길 handler 이름을 handler-mapping을 통해 받아온다.
            3. 핸들러매핑이 url을 통해서 서블릿에게 핸들러 이름을 알려준다.
            4. 핸들러 전/후 처리 인터셉터를 확인한다.
            5. 디스패처 서블릿이 핸들러에게 제어권을 넘겨주고, 핸들러는 서비스를 호출, 렌더링하는 뷰 이름을 받아와 디스패처 서블릿에게 전송한다.
            6. 뷰 이름을 뷰 리졸버에게 전달해 필요한 뷰를 생성한다.
            7. 뷰는 모델과 컨트롤러를 활용해 원하는 응답을 생성하여 클라이언트로 뷰를 응답한다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">ORM 정의와 종류에 대해</div>
        <div class="an-box">
            Object-relation mapping, 객체 관계 매핑이란 객체 지향 프로그래밍에서 객체와 관계형 DB의 테이블 데이터를 서로 매핑시켜주는 프레임워크다.
            자바에서는 대표적으로 JPA, Mybatis가 존재한다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">Mybatis 기술에 대해</div>
        <div class="an-box">
            Mybatis는 ORM기술이 아닌 SQL Builder, SQL Mapper 기술로 분류된다.
            xml 파일에 별도로 동적 쿼리문을 작성하여 DB데이터와 자바 객체를 직접적으로 매핑시켜주는 방법이다.
            SQL 쿼리를 직접 작성하므로 최적화된 쿼리를 구현하며, 다양한 테이블 조인을 자유롭게 조인이 가능하고, 복잡한 쿼리도 작성할 수 있다.
            반복된 쿼리가 발생하고, 데이터베이스 변경에 따라 로직도 함께 변경해주어야하는 번거로움이 있다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JPA 기술에 대해</div>
        <div class="an-box">
            JPA는 Java Persistence API의 약자로, ORM 기술에 대한 표준 명세이다.
            일반적으로 사용하는 JPA의 구현체는 Hinernate이다.
            JPA에서 제공하는 1차캐시, 쓰기지연, 변경감지, 지연로딩으로 성능상 이점을 얻을 수 있다.
            직접적인 쿼리문 생성 없이, 코드레벨에서 관리되므로 사용이 용이하고 생산성이 높다.
            다만 JPA만을 사용해 복잡한 쿼리문을 만들기에는 다소 무리가 있고, n+1 문제 등의 성능상 이슈가 발생할 수 있다.
            + 1차캐시(동일성보장) : JPA를 통해서 DB에서 꺼내온 객체는 JPA의 1차캐시 안에 저장된다. 이후에 테이블에서 이 값을 다시 꺼내더라도 1차캐시 상에서 동일한 값을 꺼내기 때문에 객체 역시 동일한 객체임을 보장한다.
            + 쓰기지연 : JPA는 Entity를 단순 저장한다고 바로 DB에 반영되는 것이 아닌, commit() 메소드가 실행되었을 때 쓰기지연 저장소에 저장되어있던 쿼리를 데이터베이스로 보내는 구조이다.
            + 지연로딩 : 특정 객체가 OneToMany 객체인 경우, 특정 객체를 가져올때 연관된 다른 테이블의 필요한 값은 사용할 때 필요한 값만 나중에 가져오는것이 지연 로딩이다. 이를 즉시 가져올 경우, 특정한 객체 하나만 가져왔는데, 이와 연관된 다른 테이블의 모든 객체를 각각 Select로 가져오는 문제가 발생할 수 있다.
            + 변경감지 : persist가 없더라도, Entity의 변경사항은 JPA에서 자체적으로 감지하고, 실제 DB로 업데이트해준다. 이는 1차캐시에 스냅샷이라는 공간에 값을 저장하고, Entity와 스냅샷 값의 차이가 있다면, update 쿼리로 DB에 반영하는 구조이기 때문이다.
            + n+1문제 : 지연로딩을 하더라도, 결과적으로 데이터를 가져오는 순서를 늦출 뿐, 나중에 해당 데이터를 가져온다면 다시 n개만큼의 데이터를 가져오는 n+1문제에 다다른다.
            이를 해결하기 위해서는 join 셀렉트문 하나만 실행되는 모습을 만들어야한다. 이는 Fetch join을 통해 해결할 수 있는데, jpaRepository에서 지원해주지 않으며, JPQL로 별도로 작성해야한다. 다만 이럴경우, FetchType이 무의미해지며, 페이징 단위로 데이터를 가져오는것이 불가능하며, 중복된 데이터가 컬렉션에 존재하지 않도록 주의해야한다.
            (중복된 데이터 -> Set을 사용하거나, distinct 사용)
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">DAO와 DTO란?</div>
        <div class="an-box">
            DAO는 Data Access Object로 실제 DB에 접근하는 객체를 말한다.
            DTO는 Data Transfer Object는 계층간 데이터 교환을 위한 객체이다.
            VO는 Value Object로 readonly의 특성을 가진다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JSP와 Servlet에 대해</div>
        <div class="an-box">
            Servlet은 자바를 웹 어플리케이션에서 사용하기 쉽도록 만든 API이다.
            HttpServletRequest/HttpServletResponse를 통해서
            사용자가 보낸 요청을 받고, 처리를 한 후 HttpServlertResponse에 응답 데이터를 담아 사용자에게 보여준다.
            여기서 기본 Servlet을 사용하면 자바 코드 안에 HTML코드를 일일이 기입을 해줘야 하므로, 유지보수에 어려움을 겪는다.
            이를 보완하는 JSP는 HTML안에 자바 코드를 껴넣는 방식으로 동적 웹페이지를 생성할 수 있다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 메모리영역과 상수풀에 대해</div>
        <div class="an-box">
            정적 영역(Static Area)
            클래스 파일의 기본적인 정보가 저장되는 영역이다.
            필드와 메소드정보, 그리고 final이 붙은 상수를 저장하는 상수풀과 static변수가 있다. 이 변수들은 프로그램 종료시까지 메모리에 상주하기 때문에 어디서든지 사용이 가능하다, 무분별하게 사용하면 메모리 부족이 생길 수 있다.

            스택 영역 : 자바는 한 쓰레드마다 자신의 스택을 지닌다. 메소드를 호출하면 프레임을 추가하고, 메소드 종료시, 프레임을 제거하는 형태로 되어있다.

            힙 영역 : 주로 긴 생명주기를 가진 데이터들이 저장되며, 어플의 모든 메모리 중 스택에 있는 데이터를 제외한 부분이 힙에 들어간다.
            또한 스레드가 몇개든 상관없이 힙은 딱 하나의 영역만 존재한다. 프로그램 실행중 생성되는 모든 객체는 힙 영역에 동적으로 할당되며, Garbage Collector를 통해서 메모리를 반환한다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 implements와 extends의 차이</div>
        <div class="an-box">
            자바 implements와 extends의 차이
            extends는 일반 클래스와 abstract 클래스, implement는 interface 상속에 사용된다.
            class-class와 interface-interface는 모두 extends를 사용한다.
            extends는 한 개의 클래스만 상속받을 수 있다.
            implements는 한번에 여러개 상속이 가능하다.
            implements한 클래스는 해당 interface의 모든 메소드를 재정의하여 사용해야한다.
            extends는 부모의 클래스를 상속없이 사용이 가능하다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JDBC란?</div>
        <div class="an-box">
            자바에서 DB와 연결하기 위해 사용되는 API이다.
            JDBC의 흐름은 JDBC 드라이버 로드 > DB 연결 > SQL문 실행 > DB 연결 종료 순이다.
            +JDBC 드라이버 : DB와 통신을 담당하는 자바 클래스로, DB마다 별도의 드라이버가 필요하다.
            +JDBC URL : DB와의 연결을 위한 식별값, 드라이버에 따라 형식이 다름
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 객체의 직렬화(serialVersionUID)</div>
        <div class="an-box">
            자바 객체의 직렬화
            자바의 입출력에는 스티림이라는 데이터 통로가 사용된다. 하지만 객체는 바이트형이 아니기 때문에 스트림을 통해서 파일저장하거나 네트워크로 전송이 불가능하다.
            따라서 스트림을 통해 입출력하기 위해서 바이트 배열로 변환하여야하며, 이를 직렬화라고 한다.
            이 과정에서 serialVersionUID를 사용하는데, JVM는 직렬화/역직렬화 시에 클래스에 대한 번호를 부여하며, 버전이 변경되어있다면 새로운 번호를 할당한다. 이 때 클래스 버전이 맞는지 확인하기 위해서 serailVersionUID를 사용하고, 이 값이 다르다면, InvalidClassException 에러를 반환한다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">리플렉션이란?</div>
        <div class="an-box">
            자바 Reflection
            자바의 리플렉션은 특정 객체의 구체적인 클래스 타입을 알지 못하더라도 그 클래스의 메소드, 타입, 변수를 접근할 수 있도록 해주는 자바 API이다.
            일반적으로 구체적인 클래스 타입이 정의되어 있지 않다면 메소드를 실행할 수 없다.
            스프링 프레임워크가 대표적이며, 사용되는 클래스가 어떤 타입인지는 정의되어있지 않지만, 실행시점에 의존주입을 통해서 확인하여 사용할 수 있도록 하는 매커니즘으로 되어있다.
            이것이 가능한 이유는 자바 클래스 파일은 바이트 코드로 컴파일되어 static 영역에 위치하게 되며, 클래스 이름만 알고 있다면 언제든지 static 영역에서 클래스 정보를 가져올 수 있기 때문에 가능하다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 클래스 변수 초기화 순서에 대해</div>
        <div class="an-box">
            static 변수 선언부 > 필드 변수 선언부 > 생성자 block(thread-safe한 영역)
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 쓰레드란?</div>
        <div class="an-box">
            자바 쓰레드는 프로세스에서의 하나의 실행의 흐름이다.
            멀티 스레드를 사용하면 대기시간이 발생했을 때, 기다리는 동안 다른 일을 처리할 수 있어서 처리속도가 올라가게 된다.
            쓰레드는 Runnable 인터에피스를 상속하여 만들어진다.

            쓰레드 풀이란, 지정한 쓰레드 제한을 넘어서는 쓰레드가 생성된 경우이다. 이 경우에는 앞에있는 쓰레드가 먼저 실행되고, 끝나면 다음 Runnble 객체가 들어간다. 최종적으로 실행되는 shoutdown() 메서드는 작업 큐에서 대기중인 작업들을 모두 처리한 후 쓰레디 풀을 중지시킨다.

            쓰레드 세이프는, 여러 쓰레드가 특정한 함수나 메소드에 동시에 접근해도 안전한 영역을 의미한다.
            쓰레드 세이프하지 않은 객체가 멀티스레드 메소드 안에 들어가있다면, 여러 쓰레드에서 동일한 객체를 참조하여 오류를 발생시킬 수 있다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 제너릭이란?</div>
        <div class="an-box">
            자바 제네릭은 데이터 형식에 의존하지 않고, 하나의 값이 여러가지 데이터 타입을 가질 수 있도록 하는 객체이다.
            제네릭 타입을 사용하는데에 장점은, 특정 부분에서 타입검사를 통해 잘못된 타입이 들어올 수 있는 것을 방지하며, 타입을 지정해주기 때문에 체크하고 변환해줄 필요가 없어 관리가 편하고 재사용성이 높다.
            제네릭 타입은 T(Type), E(Element), K(Key), V(Value), N(Number)가 있다.
            제네릭 타입을 특정한 범위 내로 제한해서 사용하고 싶다면, extends, super, ?를 사용할 수 있다.
            extends는 자손타입만, super는 부모타입만 사용이 가능하며, ?는 와일드카드를 의미한다. 즉, 타입이 지정되지 않는다는 것이다.
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">박싱과 언박싱이란</div>
        <div class="an-box">
            자바의 컬렉션에 들어가는 타입에는 참조형 값만 넣을 수 있다. String, Integer 와같은 것이 참조형이다.
            여기서 기본형 객체를 참조형인 Wrapper 클래스로 바꿔주는것을 박싱, 반대로 Wrapper 클래스를 기본형 으로 변경하는것을 언박싱이라고 한다.
            추가로 묵시적인 박싱이란,  임의로 박싱을 해주는 것이 아닌, 자동으로 박싱이 되는 것이며, 묵시적인 언박싱은 자동으로 언박싱이 되는 현상이다.

        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 쓰레드 교착상태란?(데드락) 그리고 해결방법은?</div>
        <div class="an-box"></div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 상속과 컴포지션의 차이</div>
        <div class="an-box"></div>
    </div>
    <div class="sp">
        <div class="sp-box">JVM의 역할은?</div>
        <div class="an-box"></div>
    </div>
    <div class="sp">
        <div class="sp-box">인터페이스와 추상객체(abstract)를 비교</div>
        <div class="an-box"></div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 4가지 특징에 대해서(추상화, 캡슐화, 상속, 다형성)</div>
        <div class="an-box"></div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 특징은?</div>
        <div class="an-box"></div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 필터와 인터셉터의 차이</div>
        <div class="an-box"></div>
    </div>
    <div class="np">
        <div class="back-box" onclick="lc('./line_jss.html')">돌아가기</div>
    </div>
</div>
<script src="./jss.js"></script>
</body>
</html>