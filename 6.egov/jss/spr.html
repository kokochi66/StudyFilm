<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>line_jss</title>
    <link rel="stylesheet" href="jss.css">
</head>
<body>

<div id="wrap">
    <div class="sp">
        <div class="sp-box">스프링 프레임워크에 대해서</div>
        <div class="an-box">
            스프링 프레임워크는 자바 플랫폼 상에서, 개발을 편하고 안정적으로 할 수 있도록 만든 툴이다. <br>
            스프링의 대표적인 특징으로는 POJO, IoC 컨테이너, DI와 DL, 그리고 AOP(관점 지향 프로그래밍)등이 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 DI와 DL에 대해서</div>
        <div class="an-box">
            Dependency Injection 즉, 의존성 주입이란 객체간의 의존관계를 외부의 조립기를 통해 조립하듯이 정의하는 IoC 컨테이너의 구체적인 구현 방식이다.<br>
            일반적으로 스프링은 Bean의 설정파일을 통해서 객체간의 의존관계를 정의하고, 실제 사용할 시에 Autowired와 같은 어노테이션을 통해서 의존성을 주입하여, new 연산자와 같은 생성자 없이 객체를 주입받게 한다.<br>
            이렇게 정의한 객체를 Dependency Lookup 즉 검색을 통해, Bean에 접근한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 IoC에 대해서</div>
        <div class="an-box">
            일반적인 자바는 개발자가 직접 new 연산자를 통해서 객체를 생성하며 제어를 해준다.<br>
            Spring에서는 설정을 통해서 스프링 컨테이너에 Bean을 등록하기만 하면 컨테이너에서 스스로 Bean의 생명주기를 관리한다.<br>
            객체에 대한 제어권이 컨테이너로 역전되기 때문에 제어의 역전(Inversion of Control)이라고 부른다.<br>
            결과적으로 객체 관리를 스프링에게 넘김으로써, 코드의 재사용이 쉬워지고, 유지보수가 간단해진다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 POJO에 대해서</div>
        <div class="an-box">
            POJO는 Plain Old Java Object의 약자로, 다른 클래스나 인터페이스를 상속/implement를 받아 추가된 클래스가 아닌, getter, setter와 같은 자바의 기본 기능만 가진 자바 객체이다.<br>
            스프링은 자바의 객체 지향적인 부분에만 집중하며, 특정 클래스나 라이브러리에 종속되지 않는 POJO 구성으로 코드를 짬으로 써, 복잡한 상속구조로부터 벗어난 형식을 띠는 특징이 있다.<br>
            이와 다르게 여러가지 복잡한 상속과 implement관계를 가진 EJB(Enterprise Java Beans)는 간단한 서비스 하나를 가져오기 위해서 복잡한 상속구조를 모두 가져와야하기 때문에 이를 해결하기 위해 모든 상속구조를 고쳐야하는 번거로움이 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 OOP에 대해서</div>
        <div class="an-box">
            Object Oriented Promgramming, 객체 지향 프로그래밍은, 프로그래밍에 필요한 데이터를 갖고 객체를 만들어, 객체간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.<br>
            장점으로는 남이만든 클래스를 쉽게 사용할 수 있고, 상속을 통한 확장이 편해서 코드 재사용에 용이하다.<br>
            그리고 특정 부분에 문제가 생기면 특정 클래스만 수정하면 되므로 유지보수가 쉬우며, 클래스 단위로 모듈화가 가능하므로 대형 프로젝트에 적합하다.<br><br>
            + 클래스 :  문제 해결을 위한 데이터를 속성, 행위, 변수, 메소드로 정의하여 추상화 시킨 것<br>
            ++ 추상화 : 공통적인 속성이나 기능을 묶어서 이름을 붙인 것<br>
            ++ 캡슐화 : 코드를 재수정없이 재활용하는 것, 접근 제어자를 통한 정보은닉(private)<br>
            ++ 상속 : 코드의 일부분을 변경해야 할 경우, 상속받은 자식 클래스에서 해당하는 기능만 다시 재정의 할 수 있게 하는 것<br>
            ++ 다형성 : 하나의 변수명, 함수명, 메소드명이 상황에 따라 다른 의미로 해석되는 것(재정의-오버라이딩)<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 AOP에 대해서</div>
        <div class="an-box">
            객체 지향 프로그래밍을 적용하더라도, 로그, 트랜잭션, 성능테스트 메서드와 같이 공통적으로 반복되는 중복코드가 발생한다.<br>
            이를 해결할 수 있도록, 스프링에서는 실행시에 비즈니스 로직의 앞과 뒤, 혹은 원하는 지점에서 해당하는 공통 관심사를 모듈화하여 실행될 수 있도록 프로그래밍하는 방식이 AOP이다.<br>
            원하는 지점에 중복되는 코드를 하나의 모듈로 줄이기 때문에 유지보수와 재사용에 용이하다는 OOP와 동일한 장점을 갖고 있다.<br><br>
            + Aspect : 여러 곳에서 사용되는 코드를 합쳐서 모듈화 한 것<br>
            + Target : Aspect가 적용되는 위치를 표시<br>
            + Advice : Aspect의 실질적 기능에 대한 구현<br>
            + Joint point : Advice가 Target에 적용되는 시점<br>
            + Pointcut + Joint point의 상세정보를 정의<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">프록시 패턴이란</div>
        <div class="an-box">
            프록시 패턴은 기존 객체를 감싸고있는 객체이며, 기존 객체와 타입이 동일하다. 주로 접근제어나, 부가기능 추가에 사용된다.<br>
            일반적으로 Service 인터페이스가 존재하고, 이를 컨트롤러에서 실행할 때, Service를 implements하는 ServiceImpl 클래스를 만들어서 구현하는 것이 이 패턴에 해당한다.<br>
        </div>
    </div>

    <div class="sp">
        <div class="sp-box">스프링과 부트의 차이점에 대해서</div>
        <div class="an-box">
            스프링 프로젝트를 생성하다보면 만나게 되는 문제점이 있다. 바로 프로젝트를 세팅하는 데에만 시간이 너무 오래걸린다는 것이다.<br>
            빈 등록을 위한 servlet 설정부터, DB연결을 위한 Hibernate Datasource, Entity Manager, Session Factory 등 스프링의 기본 설정을 하는데에는 지나치게 많은 시간이 걸린다.<br>
            스프링 부트 스타터 의존을 활용하면, spring-boot-starter-web 의존 하나에 대부분의 필요한 의존이 자동으로 추가되므로, 개발자는 Dependency 관리와 호환버전에 대해 고민할 필요가 없어지며, 대부분의 필요한 설정을 스프링 부트 스타터와 임베디드 톰캣이 알아서 해준다.<br>
            +내장톰캣 : 별도의 WAS를 이용한다던지, 톰캣에 추가 기능이 필요한 경우에는 외장WAS를 고려해야하나, 실질적으로 내장과 외장의 성능에 큰 차이는 없다고 한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링과 nodeJS의 장점과 단점</div>
        <div class="an-box">
            스프링 MVC<br>
            클라이언트가 요청시마다 쓰레드가 생성되며, 다중 쓰레드로 많은 요청을 동시에 처리할 수 있다.<br>
            너무 많은 요청을 동시에 처리하게 될 경우, 클라이언트가 요청을 계속 기다려야 하기 때문에 블로킹되는 쓰레드가 생겨난다.<br><br>

            nodeJS<br>
            한개의 쓰레드로 요청을 수행하여, 비동기적으로 블로킹 없이 I/O 작업을 수행한다.<br>
            I/O작업보다 단순 CPU 사용이 많은 작업이라면 단일스레드로 동작하는 nodeJS에 적합하지 않다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">MVC1과 MVC2에 대해</div>
        <div class="an-box">
            모델-뷰-컨트롤러 패턴으로, 데이터, DB등이 담겨져있는 모델, 사용자에게 보여지는 화면인 View, 데이터와 로직 사이에 상호동작을 돕는 Controller로 이루어진 패턴을 말한다.<br>
            MVC1패턴 : view와 controller를 모두 JSP에서 담당한다. 재사용성이 매우 떨어지고, 가독성이 떨어져 유지보수가 어려워진다.<br>
            MVC2패턴 : 스프링 프레임워크에서 사용되는 패턴이며, View와 Controller가 완전히 분리되어 유지보수가 쉬워진다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 MVC의 구조와 흐름에 대해서</div>
        <div class="an-box">
            1. dispacter-servlet이 클라이언트로부터 요청을 받는다.<br>
            2. 요청을 넘길 handler 이름을 handler-mapping을 통해 받아온다.<br>
            3. 핸들러매핑이 url을 통해서 서블릿에게 핸들러 이름을 알려준다.<br>
            4. 핸들러 전/후 처리 인터셉터를 확인한다.<br>
            5. 디스패처 서블릿이 핸들러에게 제어권을 넘겨주고, 핸들러는 서비스를 호출, 렌더링하는 뷰 이름을 받아와 디스패처 서블릿에게 전송한다.<br>
            6. 뷰 이름을 뷰 리졸버에게 전달해 필요한 뷰를 생성한다.<br>
            7. 뷰는 모델과 컨트롤러를 활용해 원하는 응답을 생성하여 클라이언트로 뷰를 응답한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">ORM 정의와 종류에 대해</div>
        <div class="an-box">
            Object-relation mapping, 객체 관계 매핑이란 객체 지향 프로그래밍에서 객체와 관계형 DB의 테이블 데이터를 서로 매핑시켜주는 프레임워크다.<br>
            자바에서는 대표적으로 JPA, Mybatis가 존재한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">Mybatis 기술에 대해</div>
        <div class="an-box">
            Mybatis는 ORM기술이 아닌 SQL Builder, SQL Mapper 기술로 분류된다.<br>
            xml 파일에 별도로 동적 쿼리문을 작성하여 DB데이터와 자바 객체를 직접적으로 매핑시켜주는 방법이다.<br>
            SQL 쿼리를 직접 작성하므로 최적화된 쿼리를 구현하며, 다양한 테이블 조인을 자유롭게 조인이 가능하고, 복잡한 쿼리도 작성할 수 있다.<br>
            반복된 쿼리가 발생하고, 데이터베이스 변경에 따라 로직도 함께 변경해주어야하는 번거로움이 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JPA 기술에 대해</div>
        <div class="an-box">
            JPA는 Java Persistence API의 약자로, ORM 기술에 대한 표준 명세이다.<br>
            일반적으로 사용하는 JPA의 구현체는 Hinernate이다.<br>
            JPA에서 제공하는 1차캐시, 쓰기지연, 변경감지, 지연로딩으로 성능상 이점을 얻을 수 있다.<br>
            직접적인 쿼리문 생성 없이, 코드레벨에서 관리되므로 사용이 용이하고 생산성이 높다.<br>
            다만 JPA만을 사용해 복잡한 쿼리문을 만들기에는 다소 무리가 있고, n+1 문제 등의 성능상 이슈가 발생할 수 있다.<br><br>
            + 1차캐시(동일성보장) : JPA를 통해서 DB에서 꺼내온 객체는 JPA의 1차캐시 안에 저장된다. 이후에 테이블에서 이 값을 다시 꺼내더라도 1차캐시 상에서 동일한 값을 꺼내기 때문에 객체 역시 동일한 객체임을 보장한다.<br>
            + 쓰기지연 : JPA는 Entity를 단순 저장한다고 바로 DB에 반영되는 것이 아닌, commit() 메소드가 실행되었을 때 쓰기지연 저장소에 저장되어있던 쿼리를 데이터베이스로 보내는 구조이다.<br>
            + 지연로딩 : 특정 객체가 OneToMany 객체인 경우, 특정 객체를 가져올때 연관된 다른 테이블의 필요한 값은 사용할 때 필요한 값만 나중에 가져오는것이 지연 로딩이다. 이를 즉시 가져올 경우, 특정한 객체 하나만 가져왔는데, 이와 연관된 다른 테이블의 모든 객체를 각각 Select로 가져오는 문제가 발생할 수 있다.<br>
            + 변경감지 : persist가 없더라도, Entity의 변경사항은 JPA에서 자체적으로 감지하고, 실제 DB로 업데이트해준다. 이는 1차캐시에 스냅샷이라는 공간에 값을 저장하고, Entity와 스냅샷 값의 차이가 있다면, update 쿼리로 DB에 반영하는 구조이기 때문이다.<br>
            + n+1문제 : 지연로딩을 하더라도, 결과적으로 데이터를 가져오는 순서를 늦출 뿐, 나중에 해당 데이터를 가져온다면 다시 n개만큼의 데이터를 가져오는 n+1문제에 다다른다.<br>
            이를 해결하기 위해서는 join 셀렉트문 하나만 실행되는 모습을 만들어야한다. 이는 Fetch join을 통해 해결할 수 있는데, jpaRepository에서 지원해주지 않으며, JPQL로 별도로 작성해야한다. <br>
            다만 이럴경우, FetchType이 무의미해지며, 페이징 단위로 데이터를 가져오는것이 불가능하며, 중복된 데이터가 컬렉션에 존재하지 않도록 주의해야한다.<br>
            (중복된 데이터 -> Set을 사용하거나, distinct 사용)<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">DAO와 DTO란?</div>
        <div class="an-box">
            DAO는 Data Access Object로 실제 DB에 접근하는 객체를 말한다.<br>
            DTO는 Data Transfer Object는 계층간 데이터 교환을 위한 객체이다.<br>
            VO는 Value Object로 readonly의 특성을 가진다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JSP와 Servlet에 대해</div>
        <div class="an-box">
            Servlet은 자바를 웹 어플리케이션에서 사용하기 쉽도록 만든 API이다.<br>
            HttpServletRequest/HttpServletResponse를 통해서<br>
            사용자가 보낸 요청을 받고, 처리를 한 후 HttpServlertResponse에 응답 데이터를 담아 사용자에게 보여준다.<br>
            여기서 기본 Servlet을 사용하면 자바 코드 안에 HTML코드를 일일이 기입을 해줘야 하므로, 유지보수에 어려움을 겪는다.<br>
            이를 보완하는 JSP는 HTML안에 자바 코드를 껴넣는 방식으로 동적 웹페이지를 생성할 수 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 메모리영역과 상수풀에 대해</div>
        <div class="an-box">
            정적 영역(Static Area)<br>
            클래스 파일의 기본적인 정보가 저장되는 영역이다.<br>
            필드와 메소드정보, 그리고 final이 붙은 상수를 저장하는 상수풀과 static변수가 있다. 이 변수들은 프로그램 종료시까지 메모리에 상주하기 때문에 어디서든지 사용이 가능하다, 무분별하게 사용하면 메모리 부족이 생길 수 있다.<br><br>

            스택 영역 : 자바는 한 쓰레드마다 자신의 스택을 지닌다. 메소드를 호출하면 프레임을 추가하고, 메소드 종료시, 프레임을 제거하는 형태로 되어있다.<br><br>

            힙 영역 : 주로 긴 생명주기를 가진 데이터들이 저장되며, 어플의 모든 메모리 중 스택에 있는 데이터를 제외한 부분이 힙에 들어간다.<br>
            또한 스레드가 몇개든 상관없이 힙은 딱 하나의 영역만 존재한다. 프로그램 실행중 생성되는 모든 객체는 힙 영역에 동적으로 할당되며, Garbage Collector를 통해서 메모리를 반환한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 implements와 extends의 차이</div>
        <div class="an-box">
            자바 implements와 extends의 차이<br>
            extends는 일반 클래스와 abstract 클래스, implement는 interface 상속에 사용된다.<br>
            class-class와 interface-interface는 모두 extends를 사용한다.<br>
            extends는 한 개의 클래스만 상속받을 수 있다.<br>
            implements는 한번에 여러개 상속이 가능하다.<br>
            implements한 클래스는 해당 interface의 모든 메소드를 재정의하여 사용해야한다.<br>
            extends는 부모의 클래스를 상속없이 사용이 가능하다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JDBC란?</div>
        <div class="an-box">
            자바에서 DB와 연결하기 위해 사용되는 API이다.<br>
            JDBC의 흐름은 JDBC 드라이버 로드 > DB 연결 > SQL문 실행 > DB 연결 종료 순이다.<br>
            +JDBC 드라이버 : DB와 통신을 담당하는 자바 클래스로, DB마다 별도의 드라이버가 필요하다.<br>
            +JDBC URL : DB와의 연결을 위한 식별값, 드라이버에 따라 형식이 다름<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 객체의 직렬화(serialVersionUID)</div>
        <div class="an-box">
            자바 객체의 직렬화<br>
            자바의 입출력에는 스티림이라는 데이터 통로가 사용된다. 하지만 객체는 바이트형이 아니기 때문에 스트림을 통해서 파일저장하거나 네트워크로 전송이 불가능하다.<br>
            따라서 스트림을 통해 입출력하기 위해서 바이트 배열로 변환하여야하며, 이를 직렬화라고 한다.<br>
            이 과정에서 serialVersionUID를 사용하는데, JVM는 직렬화/역직렬화 시에 클래스에 대한 번호를 부여하며, 버전이 변경되어있다면 새로운 번호를 할당한다. 이 때 클래스 버전이 맞는지 확인하기 위해서 serailVersionUID를 사용하고, 이 값이 다르다면, InvalidClassException 에러를 반환한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">리플렉션이란?</div>
        <div class="an-box">
            자바 Reflection<br>
            자바의 리플렉션은 특정 객체의 구체적인 클래스 타입을 알지 못하더라도 그 클래스의 메소드, 타입, 변수를 접근할 수 있도록 해주는 자바 API이다.<br>
            일반적으로 구체적인 클래스 타입이 정의되어 있지 않다면 메소드를 실행할 수 없다.<br>
            스프링 프레임워크가 대표적이며, 사용되는 클래스가 어떤 타입인지는 정의되어있지 않지만, 실행시점에 의존주입을 통해서 확인하여 사용할 수 있도록 하는 매커니즘으로 되어있다.<br>
            이것이 가능한 이유는 자바 클래스 파일은 바이트 코드로 컴파일되어 static 영역에 위치하게 되며, 클래스 이름만 알고 있다면 언제든지 static 영역에서 클래스 정보를 가져올 수 있기 때문에 가능하다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 클래스 변수 초기화 순서에 대해</div>
        <div class="an-box">
            static 변수 선언부 > 필드 변수 선언부 > 생성자 block(thread-safe한 영역)<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 쓰레드란?</div>
        <div class="an-box">
            자바 쓰레드는 프로세스에서의 하나의 실행의 흐름이다.<br>
            멀티 스레드를 사용하면 대기시간이 발생했을 때, 기다리는 동안 다른 일을 처리할 수 있어서 처리속도가 올라가게 된다.<br>
            쓰레드는 Runnable 인터에피스를 상속하여 만들어진다.<br><br>

            쓰레드 풀이란, 지정한 쓰레드 제한을 넘어서는 쓰레드가 생성된 경우이다. 이 경우에는 앞에있는 쓰레드가 먼저 실행되고, 끝나면 다음 Runnble 객체가 들어간다. 최종적으로 실행되는 shoutdown() 메서드는 작업 큐에서 대기중인 작업들을 모두 처리한 후 쓰레디 풀을 중지시킨다.<br><br>

            쓰레드 세이프는, 여러 쓰레드가 특정한 함수나 메소드에 동시에 접근해도 안전한 영역을 의미한다.<br>
            쓰레드 세이프하지 않은 객체가 멀티스레드 메소드 안에 들어가있다면, 여러 쓰레드에서 동일한 객체를 참조하여 오류를 발생시킬 수 있다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 제너릭이란?</div>
        <div class="an-box">
            자바 제네릭은 데이터 형식에 의존하지 않고, 하나의 값이 여러가지 데이터 타입을 가질 수 있도록 하는 객체이다.<br>
            제네릭 타입을 사용하는데에 장점은, 특정 부분에서 타입검사를 통해 잘못된 타입이 들어올 수 있는 것을 방지하며, 타입을 지정해주기 때문에 체크하고 변환해줄 필요가 없어 관리가 편하고 재사용성이 높다.<br>
            제네릭 타입은 T(Type), E(Element), K(Key), V(Value), N(Number)가 있다.<br>
            제네릭 타입을 특정한 범위 내로 제한해서 사용하고 싶다면, extends, super, ?를 사용할 수 있다.<br>
            extends는 자손타입만, super는 부모타입만 사용이 가능하며, ?는 와일드카드를 의미한다. 즉, 타입이 지정되지 않는다는 것이다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">박싱과 언박싱이란</div>
        <div class="an-box">
            자바의 컬렉션에 들어가는 타입에는 참조형 값만 넣을 수 있다. String, Integer 와같은 것이 참조형이다.<br>
            여기서 기본형 객체를 참조형인 Wrapper 클래스로 바꿔주는것을 박싱, 반대로 Wrapper 클래스를 기본형 으로 변경하는것을 언박싱이라고 한다.<br>
            추가로 묵시적인 박싱이란,  임의로 박싱을 해주는 것이 아닌, 자동으로 박싱이 되는 것이며, 묵시적인 언박싱은 자동으로 언박싱이 되는 현상이다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 쓰레드 교착상태란?(데드락) 그리고 해결방법은?</div>
        <div class="an-box">
            멀티 쓰레드 프로그래밍에서는 동일한 자원을 여러곳에서 사용하는것을 락을 사용하여 금지시킵니다.<br>
            이 락을 사용하면 해당 자원에 접근했을 때, 자원이 사용중이라면 자원 사용이 끝날 때 까지 기다리도록 합니다.<br>
            그런데 만약 두개의 쓰레드에서 서로 갖고있는 락이 해제되기를 무한정 기다리는 상태가 생길 수 있습니다. 이를 쓰레드 교착상태, 데드락이라고 합니다.<br>
            데드락이 발생하는 조건은 총 4가지 입니다.<br>
            상호배제(Mutual Exclusion) : 한 자원에 대해 여러 쓰레드에서 접근이 불가능한 경우<br>
            점유와 대기(Hold and Wait) : 자원을 갖고있는 상태에서 다른 쓰레드가 사용하는 자원 반납을 기다리고 있을 때<br>
            비선점(Non Preemptive) : 다른 쓰레드의 자원을 실행 중간에 가져올 수 없을 때<br>
            환형대기(Circle wait) ; 각 쓰레드가 순환적으로 다음 다음 쓰레드가 요구하는 자원을 갖고있을 때<br>
            이 4가지 중 하나라도 충족하지 않으면 데드락이 발생하지 않으며, 조건을 충족하게 하지 않는 것이 데드락을 방지하는 방법입니다.<br>

        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바 상속과 컴포지션의 차이</div>
        <div class="an-box">
            상속은 IS-A 관계, 컴포지션은 각 객체들간의 HAS-A 관계로 생성하는 것입니다.<br>
            상속은 클래스를 확장해서 부모 클래스에서 데이터를 그대로 물려받는 기능이며, 컴포지션은 클래스 내부의 데이터로 다른 클래스의 객체를 포함할 수 있게 하는 것입니다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">객체지향 개발 5대 원리(SOLID)</div>
        <div class="an-box">
            SRP(단일책임의 원칙) ; 작성되는 클래스는 하나의 기능만 가지며, 제공하는 모든 서비스가 그 하나의 책임을 수행하는데에 집중된다<br>
            ( 책임의 영역이 확실해지기 때문에 한 책임의 변경으로 인한 연쇄작용으로부터 자유로울 수 있어야 한다.)<br><br>

            OCP(개방폐쇄의 원칙) : 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소의 수정은 일어나지 않아야 하며, 기존 구성요소를 쉽게 확장하여 재사용이 가능하도록 만들어야 한다.<br><br>

            LSP(리스코브 치환의 원칙) : 서브타입은 언제나 기반 타입으로 교체할 수 있어야한다( 하위 객체는 항상 상위 객체로 교체가 가능해야한다. )<br>
            ( 상속을 사용하기 위해서는 하위클래스와 상위 클래스간의 IS-A 관계가 있을때만 사용해야하며, 이외의 HAS-A 관계인 경우에는 합성(composition)을 사용해야한다.<br><br>

            ISP(인터페이스 분리의 원칙) : 어떤 클래스가 다른 클래스에 종속되느 경우, 최소한의 인터페이스만을 사용해야한다. 하나의 클래스가 여러 인터페이스를 사용하는 경우, 상속을 하거나, 위임을 통해서 인터페이스를 분리해야한다.<br>
            ( 두 개 이상의 인터페이스가 공유하는 부분의 재사용을 극대화하며, 서로 다른 성격의 인터페이스를 명백히 분리해야한다)<br><br>

            DIP(의존성역전의 원칙) : 상위 계층이 하위 계층에 의존적인 전통의 방식과 달리, 자바는 하위 계층이 상위 계층에게 의존적이게 되며, 상위 계층은 하위 계층의 구현으로부터 독립되어 사용될 수 있게 된다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">JVM의 역할은?</div>
        <div class="an-box">
            JVM은 자바를 실행하기위한 가상 기계로, 자바의 바이트 코드를 운영체제에 맞게 해석해주고 실행시켜주는 역할을 한다.<br>
            바이트 코드는 기계어가 아니기 때문에 운영체제에서 바로 실행될수 없다. 이를 운영체제가 이해할 수 있도록 변환해주는것이 JVM의 역할이다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">인터페이스와 추상객체(abstract)를 비교</div>
        <div class="an-box">
            추상클래스는 추상 메서드를 선언하여, 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스이다.<br>
            상속을 위한 클래스이므로, 객체를 별도로 생성할 수 없다.<br><br>

            인터페이스를 사용해서 기본 틀을 구성한다면, 인터페이스의 특징상 모든 기능들을 하위 클래스에서 오버라이딩해야한다.<br>
            그렇다고 extends 상속만을 사용하기엔 extends는 하나의 클래스만 상속받을 수 있다. 그렇기에 상황에 맞게 상속을 사용해야한다.<br>
        </div>
    </div>
    <div class="sp">
        <div class="sp-box">자바의 4가지 특징에 대해서(추상화, 캡슐화, 상속, 다형성)</div>
        <div class="an-box">
            추상화 : 객체와 관련된 속성의 이름만을 표시하며, 해당 부분의 세부 정보는 별도의 구현 파일로 숨긴다. (interface에 메소드만을 선언하고, 실제 구현은 상속받은 java 파일에서 작성하는 것)<br>
            캡슐화 : 변경가능성이 높은 부분은 내부로 숨기고, 외부에는 상대적으로 안정적인 부분만 공개한다. (변경가능성이 높은 부분을 모듈화하여 메소드로 만드는 것)<br>
            상속 : 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게 하고, 기능의 일부분을 변경해야할 경우 상속받은 자식 클래스에서 해당 기능만을 재정의하여 사용할 수 있게 한다.<br>
            다형성 : 하나의 변수명,함수명 등이 상황에 따라 다른 의미로 해석될 수 있다. <br>
            (오버라이딩 - 부모클래스와 같은 메소드이름을 재엉의, 오버로딩 - 같은 이름의 함수를 여러개 정의하고, 파라미터를 다르게하여, 파라미터에 따라 다른 메소드가 호출되도록 함)<br>

        </div>
    </div>
    <div class="sp">
        <div class="sp-box">스프링 필터와 인터셉터의 차이</div>
        <div class="an-box">
            필터는 스프링 컨테이너가 아닌, 톰캣과 같은 웹 컨테이너에 의해 관리가 되며 ,스프링 디스패처 서블릿으로 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리한다.<br>
            메소드로는 init, doFilter, destroy메소드가 존재한다.<br>
            init : 필터 객체를 초기화하고, 서비스에 추가한다. 1회 메소드 호출한다.<br>
            doFilter : url-pattern에 맞는 모든 HTTP 요청이 전달되기 전/후에 실행되는 메소드이다.<br>
            destroy : 필터 객체를 서비스에서 제거하고, 사용하는 자원을 반환하기 위한 메소드이다.<br>
            보안 관련 공통작업, 문자열 인코딩/압축 등의 작업에 적합하다<br><br>


            인터셉터는 Spring이 제공하는 기술로써, 디스패처 서블릿에서 컨트롤러를 호출하기 전/후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다.<br>
            preHandle : 컨트롤러가 호출되기 전에 실행된다.<br>
            postHandle : 컨트롤러가 호출된 후에 실행된다.<br>
            afterCompletion : 모든 뷰에서 모든 작업이 완료된 후에 실행되며, 리소스를 반환할 때 사용하기에 적합하다.<br>
            인증/인가 등의 공통작업, API 호출에 대한 로깅 등의 작업에 적합하다.<br><br>

            AOP기능을 사용해서 인터셉터를 대신하는 방안을 생가갛ㄹ 수 있지만, Spring의 컨트롤러는 타입과 실행 메소드, 파라미터, 리턴값이 일정하지 않기 때문에 AOP를 적용하기 위해서는 번거로운 부가작업이 생기게 된다.<br>
            그러므로 컨트롤러의 호출과정에 적용되는 부가기능들은 인터셉터를 사용하는 편이 더 낫다.<br>
        </div>
    </div>

    <div class="np">
        <div class="back-box" onclick="lc('./line_jss.html')">돌아가기</div>
    </div>
</div>
<script src="./jss.js"></script>
</body>
</html>